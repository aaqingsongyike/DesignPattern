# 装饰者模式
    1）运行时扩展，要比编译时的继承威力更大；
    2）装饰者模式，能够在不修改任何底层代码的情况下，给你的对象赋予新的职责；
    3）定义：利用组合和委托可以在运行时具有继承行为的效果，利用继承设计子类的行为，是在编译时静态决定的，
    而且所有的子类都会继承相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态进行
    扩展；
    4）做法：把多个职责，甚至时设计超类时还没有想到的职责加到对象上。通过动态的组合对象，可以写新的代码
    添加新功能，而无须修改现有代码；
    5）设计原则：对扩展开放，对修改关闭；

# 装饰者模式的使用方法：
    1）装饰者和被装饰者对象有相同的超类型；
    2）可以用一个或多个装饰者包装一个对象；
    3）既然装饰者和被装饰者有相同的超类型，所以在任何需要原始对象的场合，可以用装饰过的对象代替它；
    4）装饰者可以在所委托被装饰者的行为之前与之后，加上自己的行为，以达到特定的目的；
    5）对象可以在任何时候被装饰，所以可以在运行是动态的、不限量的用装饰者装饰对象。
    